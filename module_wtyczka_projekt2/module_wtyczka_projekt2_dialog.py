# -*- coding: utf-8 -*-
"""
/***************************************************************************
 wtyczka_projekt2Dialog
                                 A QGIS plugin
 Wtyczka do projektu 2
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-06-03
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Aleksander Przybysz
        email                : 01179211@pw.edu.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import QgsMessageLog, Qgis, QgsProject, QgsPointXY, QgsGeometry, QgsFeature, QgsVectorLayer
from qgis.utils import iface
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QDialog, QApplication, QMessageBox

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'module_wtyczka_projekt2_dialog_base.ui'))


class wtyczka_projekt2Dialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(wtyczka_projekt2Dialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        
        # jednostki pola
        self.ComboBox_area_format.addItems(["m2", "ary", "hektary"])
        
        self.pushButton_dh_calculate.clicked.connect(self.calculate_dh)
        self.pushButton_area_calculate.clicked.connect(self.calculate_area)
        self.pushButton_clear_selection.clicked.connect(self.clear_selection)
            
    def calculate_dh(self):
        current_layer = self.mMapLayerComboBox.currentLayer()
        if current_layer is None:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText('Nie wybrano warstwy')
            msg.setInformativeText("Proszę wybrać warstwę do obliczeń")
            msg.setWindowTitle("Brak danych")
            msg.exec_()
            return
    
        selected_features = current_layer.selectedFeatures()
    
        if len(selected_features) != 2:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText('Nieodpowiednia ilość punktów.')
            msg.setInformativeText("Proszę zaznaczyć dokładnie dwa punkty")
            msg.setWindowTitle("Za mało danych")
            msg.exec_()
            return
    
        try:
            h_1 = float(selected_features[0]['wysokosc'])
            h_2 = float(selected_features[1]['wysokosc'])
            d_h = h_2 - h_1
            dh = round(d_h, 3)
        except (ValueError, KeyError) as e:
            QgsMessageLog.logMessage(f'Błąd podczas odczytu wartości "wysokosc" lub konwersji na float: {e}', level=Qgis.Critical)
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText('Błąd danych')
            msg.setInformativeText("Wystąpił problem z odczytem wartości atrybutów.")
            msg.setWindowTitle("Błąd danych")
            msg.exec_()
            return
        
        self.label_dh_result.setText(f'{dh} m')
        QgsMessageLog.logMessage(f'Różnica wysokości między wybranymi punktami wynosi: {dh} m', level=Qgis.Success)
        iface.messageBar().pushMessage('Przewyższenie', 'Obliczono wysokość pomiędzy punktami', level=Qgis.Success)


    def calculate_area(self):
        current_layer_area = self.mMapLayerComboBox_area.currentLayer()
        if current_layer_area is None:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText('Nie wybrano warstwy')
            msg.setInformativeText("Wybierz warstwę do obliczeń")
            msg.setWindowTitle("Brak danych")
            msg.exec_()
            return
        
        selected_features_area = current_layer_area.selectedFeatures()
        if len(selected_features_area) < 3:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText('Zaznacz co najmniej 3 punkty.')
            msg.setInformativeText("Nieprawidłowa ilość danych")
            msg.setWindowTitle("Za mało danych")
            msg.exec_()
            return
        
        coords_x = []
        coords_y = []
        
        for point in selected_features_area:
            geo = point.geometry()
            x = float(geo.asPoint().x())
            y = float(geo.asPoint().y())
            coords_x.append(x)
            coords_y.append(y)
        
        points_xy = list(zip(coords_x, coords_y))
        
        area = 0.0
        n = len(points_xy)
        for i in range(n):
            area += points_xy[i][0] * (points_xy[(i + 1) % n][1] - points_xy[(i - 1) % n][1])
        area = 0.5 * abs(area)
        
        area_unit = self.ComboBox_area_format.currentText()
        if area_unit == 'ary':
            area /= 100  # Przelicza m2 na ary
            area_unit = 'a'
        elif area_unit == 'hektary':
            area /= 10000  # Przelicza m2 na hektary
            area_unit = 'ha'
        else:
            area_unit = 'm²'

        area = round(area, 3)
        
        self.label_area_result.setText(f'{area} {area_unit}')
        QgsMessageLog.logMessage(f'Pole powierzchni wynosi: {area} {area_unit}', level=Qgis.Success)
        iface.messageBar().pushMessage("Pole powierzchni", f'Obliczono pole powierzchni: {area} {area_unit}', level=Qgis.Success)

        # poligon porównania
        new_layer = QgsVectorLayer("Polygon?crs=EPSG:2180", "polygon_area_ref", "memory")
        points = [QgsPointXY(x, y) for x, y in points_xy]
        polygon_geom = QgsGeometry.fromPolygonXY([[point for point in points]])
        new_feature = QgsFeature()
        new_feature.setGeometry(polygon_geom)
        new_layer.dataProvider().addFeatures([new_feature])
        
        # nowa warstwa tymczasowa
        QgsProject.instance().addMapLayer(new_layer)
        
        # sprawdzenie pola poligonu
        for feat in new_layer.getFeatures():
            area_geom = feat.geometry().area()
            QgsMessageLog.logMessage(f'Pole powierzchni poligonu porównania wynosi: {area_geom:.3f}', level=Qgis.Success)
            self.label_area_result_ref.setText(f'{area:.3f} {area_unit}')
            
    def clear_selection(self):
        iface.messageBar().clearWidgets()
        iface.messageBar().pushMessage("", level=Qgis.Success)
        
        selected_layer = self.mMapLayerComboBox.currentLayer()
        if selected_layer:
            selected_layer.removeSelection()
        else:
            QgsMessageLog.logMessage("Nie wybrano warstwy.", level=Qgis.Warning)
            
        # usuwa warstwę tymczasową z polem poligonu
        project = QgsProject.instance()
        if project.mapLayersByName("polygon_area_ref"):
            project.removeMapLayer(project.mapLayersByName("polygon_area_ref")[0])